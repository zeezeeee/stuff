=== POSITION VARIABLES ===
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
vec2 pos = floor(collimator_uv*windowSize);
pos.x += time * pos.y;
float randColor = fract(sin(dot(pos.xy, vec2(12.9898,78.233))) * 43758.5453);
vec2 pos = gl_FragCoord.xy;
float dis = distance(pos, center);
vec2 k = pos - innerCircleCenter;
float innerCircleDistance = distance(pos, innerCircleCenter);
vec2 uv = fract((pos) / s);
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
float getPoint(vec4 line, vec2 position){
float cd = length(crPoint - position);
float getLine(vec4 line, vec2 position){
float a = length(line.xy - position);
float b = length(line.zw - position);
float centerF = length(position - center);
vec2 position = (gl_FragCoord.xy / resolution.xy);
position.x *= resolution.x / resolution.y;
vec4 result = getLine(l, position) * color;
result = max(result, getPoint(l, position) * color);
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
layout(location = 6) in vec4 Input_Alpha_Dist_UV;
layout(location = 7) in vec2 Input_BlendUV;
layout(location = 8) in vec4 Input_Blend_Alpha_Dist_UV;
layout(location = 9) in float Input_FlipbookIndex;
layout(location = 10) in float Input_AlphaThreshold;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
varying vec3 pos;#version 110
vec2 position = gl_FragCoord.xy / scale;
vec2 p = position * v + time * 1500. + 50.;
vec2 pos = gl_FragCoord.xy;
vec2 delta = center - pos;
varying vec3 pos;#version 110
vec2 pos = gl_FragCoord.xy/8.0;%#version 110
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
vec2 pos = gl_FragCoord.xy/8.0;
int column = int(pos.x);
int row = int(pos.y);
if (int(mod(pos.x, 2.0)) == int(mod(pos.y, 2.0))) {
vec2 position = gl_FragCoord.xy / scale;
vec2 p = position * v + time * 1500. + 50.;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
layout(location = 6) in vec4 Input_Alpha_Dist_UV;
layout(location = 7) in vec2 Input_BlendUV;
layout(location = 8) in vec4 Input_Blend_Alpha_Dist_UV;
layout(location = 9) in float Input_FlipbookIndex;
layout(location = 10) in float Input_AlphaThreshold;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
varying vec3 pos;
vec3 uvw = pos;
float r0 = sqrt(pos.x * pos.x + pos.z * pos.z);
float a0 = atan(-pos.z, pos.x);
vec3 offset = vec3(cos(a + r * m - time) * s, 0.0, sin(a + r * m - time) * s) * vec3(0.0110) * normalize(pos).y * normalize(pos).y;
vec4 skyTextureData = textureCube(skyboxTexture, pos);
skyColor.rgb *= max(0.0, normalize(pos).y);
vec3 uvw = pos;
vec3 offset = vec3(sin(time + pos.x * s), 0.0, cos(time + pos.z * s)) * vec3(0.0110) * normalize(pos).y;
skyColor += textureCube(skyboxTexture, pos).xyz * (0.5 + strike * 0.5 * ejectionStrength + 0.5 * (1.0 - ejectionStrength));
vec4 skyTextureData = textureCube(skyboxTexture, pos, 0.0);
varying vec3 pos;
pos = original.xyz;
varying vec3 pos;
vec3 uvw = pos;
float r0 = sqrt(pos.x * pos.x + pos.z * pos.z);
float a0 = atan(-pos.z, pos.x);
vec3 offset = vec3(cos(a + r * m - time) * s, 0.0, sin(a + r * m - time) * s) * vec3(0.0110) * normalize(pos).y * normalize(pos).y;
vec4 skyTextureData = textureCube(skyboxTexture, pos);
skyColor.rgb *= max(0.0, normalize(pos).y);
vec3 uvw = pos;
vec3 offset = vec3(sin(time + pos.x * s), 0.0, cos(time + pos.z * s)) * vec3(0.0110) * normalize(pos).y;
skyColor += textureCube(skyboxTexture, pos).xyz * (0.5 + strike * 0.5 * ejectionStrength + 0.5 * (1.0 - ejectionStrength));
vec4 skyTextureData = textureCube(skyboxTexture, pos, 0.0);
varying vec3 pos;
pos = original.xyz;
vec3 Pos;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 VP = vec3(gl_LightSource[i].position);
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
layout(location = 6) in vec4 Input_Alpha_Dist_UV;
layout(location = 7) in vec2 Input_BlendUV;
layout(location = 8) in vec4 Input_Blend_Alpha_Dist_UV;
layout(location = 9) in float Input_FlipbookIndex;
layout(location = 10) in float Input_AlphaThreshold;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 VP = vec3(gl_LightSource[i].position);
vec3 VP = vec3(gl_LightSource[i].position);
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
layout(location = 6) in vec4 Input_Alpha_Dist_UV;
layout(location = 7) in vec2 Input_BlendUV;
layout(location = 8) in vec4 Input_Blend_Alpha_Dist_UV;
layout(location = 9) in float Input_FlipbookIndex;
layout(location = 10) in float Input_AlphaThreshold;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
float getPoint(vec4 line, vec2 position){
float cd = length(crPoint - position);
float getLine(vec4 line, vec2 position){
float a = length(line.xy - position);
float b = length(line.zw - position);
float centerF = length(position - center);
vec2 position = (gl_FragCoord.xy / resolution.xy);
position.x *= resolution.x / resolution.y;
vec4 result = getLine(l, position) * color;
result = max(result, getPoint(l, position) * color);
void wind(vec3 worldPos, inout vec4 pos, inout vec3 colorAdd, float power) {
pos.y -= positionIn.y * str * 0.3;
pos.xz += dtn * str * positionIn.y * 1.0;
vec4 pos = vec4(1.0);
pos.xyz = viewPos + vpos.xyz * vec3(2.0, height, 2.0);
pos.xz += downed * pos.xz * baseHeight * positionIn.y;
wind(worldPos, pos, grassColor, windPower);
pixelWorldPos = pos.xyz;
gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * pos;
vec3 Pos;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
in vec3 pos[1];
vec3 instancePos = pos[0];
out vec3 pos;
pos = instancePos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec2 Input_UV;
layout(location = 3) in vec4 Input_Alpha_Dist_UV;
layout(location = 4) in vec2 Input_BlendUV;
layout(location = 5) in vec4 Input_Blend_Alpha_Dist_UV;
layout(location = 6) in float Input_FlipbookIndex;
layout(location = 7) in float Input_AlphaThreshold;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec2 Input_UV;
layout(location = 3) in vec4 Input_Alpha_Dist_UV;
layout(location = 4) in vec2 Input_BlendUV;
layout(location = 5) in vec4 Input_Blend_Alpha_Dist_UV;
layout(location = 6) in float Input_FlipbookIndex;
layout(location = 7) in float Input_AlphaThreshold;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
vec2 pos = floor(collimator_uv*windowSize);
pos.x += time * pos.y;
float randColor = fract(sin(dot(pos.xy, vec2(12.9898,78.233))) * 43758.5453);
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
in vec3 pos;
float fogAmount = ComputeVolumetricFog(pos, 1.0);
vec3 fogColor = getFogColor(pos);
out vec3 pos;
pos = rotatedPos.xyz;
layout(location = 0) out highp vec4 _entryPointOutput;
highp vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
highp vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
varying vec3 pos;
pos = (gl_ModelViewMatrix * gl_Vertex).xyz;
varying vec3 pos;
vec3 eye = normalize(-pos);
float oa = smoothstep(0.5, 3.0, length(pos));
varying vec3 pos;
vec3 eye = normalize(-pos);
float oa = smoothstep(0.5, 3.0, length(pos));
varying vec3 pos;
pos = (gl_ModelViewMatrix * gl_Vertex).xyz;
in vec3 pos;
color.rgb = ComputeVolumetricFog(color.rgb, pos, lightmapUv.y);
out vec3 pos;
pos = localPos + chunkPos;
worldPos = pos + playerPos;
tpos = (gl_ModelViewMatrix * vec4(pos, 1.0)).xyz;
gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * vec4(pos, 1.0);
varying vec3 pos;
vec3 uvw = pos;
float r0 = sqrt(pos.x * pos.x + pos.z * pos.z);
float a0 = atan(-pos.z, pos.x);
vec3 offset = vec3(cos(a + r * m - time) * s, 0.0, sin(a + r * m - time) * s) * vec3(0.0110) * normalize(pos).y * normalize(pos).y;
vec4 skyTextureData = textureCube(skyboxTexture, pos);
skyColor.rgb *= max(0.0, normalize(pos).y);
vec3 uvw = pos;
vec3 offset = vec3(sin(time + pos.x * s), 0.0, cos(time + pos.z * s)) * vec3(0.0110) * normalize(pos).y;
skyColor += textureCube(skyboxTexture, pos).xyz * (0.5 + strike * 0.5 * ejectionStrength + 0.5 * (1.0 - ejectionStrength));
vec4 skyTextureData = textureCube(skyboxTexture, pos, 0.0);
vec2 position = gl_FragCoord.xy / scale;
vec2 p = position * v + time * 1500. + 50.;
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = gl_FragCoord.xy;
vec2 delta = center - pos;
layout(location = 0) out highp vec4 _entryPointOutput;
varying vec3 pos;
pos = original.xyz;
vec2 pos = floor(collimator_uv*windowSize);
pos.x += time * pos.y;
float randColor = fract(sin(dot(pos.xy, vec2(12.9898,78.233))) * 43758.5453);
layout(location = 0) out vec4 _entryPointOutput;
vec3 VP = vec3(gl_LightSource[i].position);
vec3 VP = vec3(gl_LightSource[i].position);
varying vec3 pos;
vec3 eye = normalize(-pos);
float oa = smoothstep(0.5, 3.0, length(pos));
varying vec3 pos;
pos = (gl_ModelViewMatrix * gl_Vertex).xyz;
layout(location = 0) out highp vec4 _entryPointOutput;
varying vec3 pos;
vec3 eye = normalize(-pos);
float oa = smoothstep(0.5, 3.0, length(pos));
varying vec3 pos;
pos = (gl_ModelViewMatrix * gl_Vertex).xyz;
in vec3 pos;
float fogAmount = ComputeVolumetricFog(pos, 1.0);
vec3 fogColor = getFogColor(pos);
out vec3 pos;
pos = rotatedPos.xyz;
in vec3 pos;
color.rgb = ComputeVolumetricFog(color.rgb, pos, lightmapUv.y);
out vec3 pos;
pos = localPos + chunkPos;
worldPos = pos + playerPos;
tpos = (gl_ModelViewMatrix * vec4(pos, 1.0)).xyz;
gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * vec4(pos, 1.0);
vec3 Pos;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
float getPoint(vec4 line, vec2 position){
float cd = length(crPoint - position);
float getLine(vec4 line, vec2 position){
float a = length(line.xy - position);
float b = length(line.zw - position);
float centerF = length(position - center);
vec2 position = (gl_FragCoord.xy / resolution.xy);
position.x *= resolution.x / resolution.y;
vec4 result = getLine(l, position) * color;
result = max(result, getPoint(l, position) * color);
vec2 pos = gl_FragCoord.xy;
float dis = distance(pos, center);
vec2 k = pos - innerCircleCenter;
float innerCircleDistance = distance(pos, innerCircleCenter);
vec2 uv = fract((pos) / s);
vec2 pos = uv * resolution;
color = clamp(1.0 - (pos.y + 25.0) / resolution.y, 0.0, 1.0);
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out highp vec4 _entryPointOutput;
highp vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
highp vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
vec3 Pos;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 VP = vec3(gl_LightSource[i].position);
varying vec3 pos;
vec3 uvw = pos;
float r0 = sqrt(pos.x * pos.x + pos.z * pos.z);
float a0 = atan(-pos.z, pos.x);
vec3 offset = vec3(cos(a + r * m - time) * s, 0.0, sin(a + r * m - time) * s) * vec3(0.0110) * normalize(pos).y * normalize(pos).y;
vec4 skyTextureData = textureCube(skyboxTexture, pos);
skyColor.rgb *= max(0.0, normalize(pos).y);
vec3 uvw = pos;
vec3 offset = vec3(sin(time + pos.x * s), 0.0, cos(time + pos.z * s)) * vec3(0.0110) * normalize(pos).y;
skyColor += textureCube(skyboxTexture, pos).xyz * (0.5 + strike * 0.5 * ejectionStrength + 0.5 * (1.0 - ejectionStrength));
vec4 skyTextureData = textureCube(skyboxTexture, pos, 0.0);
varying vec3 pos;
pos = original.xyz;
varying vec3 pos;
vec3 uvw = pos;
float r0 = sqrt(pos.x * pos.x + pos.z * pos.z);
float a0 = atan(-pos.z, pos.x);
vec3 offset = vec3(cos(a + r * m - time) * s, 0.0, sin(a + r * m - time) * s) * vec3(0.0110) * normalize(pos).y * normalize(pos).y;
vec4 skyTextureData = textureCube(skyboxTexture, pos);
skyColor.rgb *= max(0.0, normalize(pos).y);
vec3 uvw = pos;
vec3 offset = vec3(sin(time + pos.x * s), 0.0, cos(time + pos.z * s)) * vec3(0.0110) * normalize(pos).y;
skyColor += textureCube(skyboxTexture, pos).xyz * (0.5 + strike * 0.5 * ejectionStrength + 0.5 * (1.0 - ejectionStrength));
vec4 skyTextureData = textureCube(skyboxTexture, pos, 0.0);
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
varying vec3 pos;
pos = original.xyz;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec2 pos = floor(collimator_uv*windowSize);
pos.x += time * pos.y;
float randColor = fract(sin(dot(pos.xy, vec2(12.9898,78.233))) * 43758.5453);
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec2 Input_UV;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec2 Input_UV;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
layout(location = 0) out highp vec4 _entryPointOutput;
highp vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
highp vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
out vec3 pos;
pos = instancePos;
in vec3 pos[1];
vec3 instancePos = pos[0];
vec3 Pos;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
void wind(vec3 worldPos, inout vec4 pos, inout vec3 colorAdd, float power) {
pos.y -= positionIn.y * str * 0.3;
pos.xz += dtn * str * positionIn.y * 1.0;
vec4 pos = vec4(1.0);
pos.xyz = viewPos + vpos.xyz * vec3(2.0, height, 2.0);
pos.xz += downed * pos.xz * baseHeight * positionIn.y;
wind(worldPos, pos, grassColor, windPower);
pixelWorldPos = pos.xyz;
gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * pos;
layout(location = 0) out vec4 _entryPointOutput;
layout(location = 0) out highp vec4 _entryPointOutput;
vec3 Pos;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out vec4 _entryPointOutput;
layout(location = 0) out vec4 _entryPointOutput;
layout(location = 0) out highp vec4 _entryPointOutput;
vec3 Pos;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
layout(location = 0) out highp vec4 _entryPointOutput;
highp vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
highp vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
vec3 Pos;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
in vec3 pos;
float fogAmount = ComputeVolumetricFog(pos, 1.0);
vec3 fogColor = getFogColor(pos);
layout (location = 0) out vec4 FRAGCOLOR;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out vec4 _entryPointOutput;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
layout(location = 6) in vec4 Input_Alpha_Dist_UV;
layout(location = 7) in vec2 Input_BlendUV;
layout(location = 8) in vec4 Input_Blend_Alpha_Dist_UV;
layout(location = 9) in float Input_FlipbookIndex;
layout(location = 10) in float Input_AlphaThreshold;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout (location = 0) out vec4 FRAGCOLOR;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout (location = 0) out vec4 FRAGCOLOR;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out highp vec4 _entryPointOutput;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec2 Input_UV;
layout(location = 3) in vec4 Input_Alpha_Dist_UV;
layout(location = 4) in vec2 Input_BlendUV;
layout(location = 5) in vec4 Input_Blend_Alpha_Dist_UV;
layout(location = 6) in float Input_FlipbookIndex;
layout(location = 7) in float Input_AlphaThreshold;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout(location = 0) out vec4 _entryPointOutput;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout(location = 0) out vec4 _entryPointOutput;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec2 Input_UV;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out vec4 _entryPointOutput;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
layout(location = 6) in vec4 Input_Alpha_Dist_UV;
layout(location = 7) in vec2 Input_BlendUV;
layout(location = 8) in vec4 Input_Blend_Alpha_Dist_UV;
layout(location = 9) in float Input_FlipbookIndex;
layout(location = 10) in float Input_AlphaThreshold;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec2 Input_UV;
layout(location = 3) in vec4 Input_Alpha_Dist_UV;
layout(location = 4) in vec2 Input_BlendUV;
layout(location = 5) in vec4 Input_Blend_Alpha_Dist_UV;
layout(location = 6) in float Input_FlipbookIndex;
layout(location = 7) in float Input_AlphaThreshold;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out highp vec4 _entryPointOutput;
layout (location = 0) out vec4 FRAGCOLOR;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
layout(location = 0) out vec4 _entryPointOutput;
layout (location = 0) out vec4 FRAGCOLOR;
layout(location = 0) out vec4 _entryPointOutput;
vec3 Pos;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout (location = 0) out vec4 FRAGCOLOR;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out vec4 _entryPointOutput;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
layout(location = 0) out vec4 _entryPointOutput;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out vec4 _entryPointOutput;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec2 Input_UV;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
layout(location = 6) in vec4 Input_Alpha_Dist_UV;
layout(location = 7) in vec2 Input_BlendUV;
layout(location = 8) in vec4 Input_Blend_Alpha_Dist_UV;
layout(location = 9) in float Input_FlipbookIndex;
layout(location = 10) in float Input_AlphaThreshold;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout (location = 0) out vec4 FRAGCOLOR;
layout(location = 0) out vec4 _entryPointOutput;
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPosition = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout (location = 0) out vec4 FRAGCOLOR;
layout(location = 0) out highp vec4 _entryPointOutput;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec4 Input_Color;
layout(location = 2) in vec4 Input_Normal;
layout(location = 3) in vec4 Input_Tangent;
layout(location = 4) in vec2 Input_UV1;
layout(location = 5) in vec2 Input_UV2;
layout(location = 6) in vec4 Input_Alpha_Dist_UV;
layout(location = 7) in vec2 Input_BlendUV;
layout(location = 8) in vec4 Input_Blend_Alpha_Dist_UV;
layout(location = 9) in float Input_FlipbookIndex;
layout(location = 10) in float Input_AlphaThreshold;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec3 Pos;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out vec4 _entryPointOutput;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
layout(location = 0) out vec4 _entryPointOutput;
layout(location = 0) out vec4 _entryPointOutput;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
vec3 Pos;
layout(location = 0) in vec3 Input_Pos;
layout(location = 1) in vec3 Input_Normal;
layout(location = 2) in vec3 Input_Binormal;
layout(location = 3) in vec3 Input_Tangent;
layout(location = 4) in vec2 Input_UV;
layout(location = 5) in vec4 Input_Color;
vec4 localPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;
vec2 pos = uv * resolution;
color = clamp(1.0 - (pos.y + 25.0) / resolution.y, 0.0, 1.0);
layout(location = 0) out vec4 _entryPointOutput;
layout(location = 0) out vec4 _entryPointOutput;
layout(location = 0) out vec4 _entryPointOutput;
vec2 pos = Input.PosP.xy / vec2(Input.PosP.w);
vec2 uv = (pos + ((posR - pos) * xscale)) + ((posU - pos) * yscale);
vec2 pos = gl_FragCoord.xy;
vec2 delta = center - pos;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout(location = 0) out vec4 _entryPointOutput;
layout (location = 0) out vec4 FRAGCOLOR;
layout(location = 0) out vec4 _entryPointOutput;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
varying vec3 pos;
vec3 uvw = pos;
float r0 = sqrt(pos.x * pos.x + pos.z * pos.z);
float a0 = atan(-pos.z, pos.x);
vec3 offset = vec3(cos(a + r * m - time) * s, 0.0, sin(a + r * m - time) * s) * vec3(0.0110) * normalize(pos).y * normalize(pos).y;
vec4 skyTextureData = textureCube(skyboxTexture, pos);
skyColor.rgb *= max(0.0, normalize(pos).y);
vec3 uvw = pos;
vec3 offset = vec3(sin(time + pos.x * s), 0.0, cos(time + pos.z * s)) * vec3(0.0110) * normalize(pos).y;
skyColor += textureCube(skyboxTexture, pos).xyz * (0.5 + strike * 0.5 * ejectionStrength + 0.5 * (1.0 - ejectionStrength));
vec4 skyTextureData = textureCube(skyboxTexture, pos, 0.0);
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout(location = 0) out vec4 _entryPointOutput;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
#define LAYOUT(ind) layout(location = ind)
varying vec3 pos;
vec3 uvw = pos;
float r0 = sqrt(pos.x * pos.x + pos.z * pos.z);
float a0 = atan(-pos.z, pos.x);
vec3 offset = vec3(cos(a + r * m - time) * s, 0.0, sin(a + r * m - time) * s) * vec3(0.0110) * normalize(pos).y * normalize(pos).y;
vec4 skyTextureData = textureCube(skyboxTexture, pos);
skyColor.rgb *= max(0.0, normalize(pos).y);
vec3 uvw = pos;
vec3 offset = vec3(sin(time + pos.x * s), 0.0, cos(time + pos.z * s)) * vec3(0.0110) * normalize(pos).y;
skyColor += textureCube(skyboxTexture, pos).xyz * (0.5 + strike * 0.5 * ejectionStrength + 0.5 * (1.0 - ejectionStrength));
vec4 skyTextureData = textureCube(skyboxTexture, pos, 0.0);
layout (location = 0) out vec4 FRAGCOLOR;
varying vec3 pos;
vec3 uvw = pos;
float r0 = sqrt(pos.x * pos.x + pos.z * pos.z);
float a0 = atan(-pos.z, pos.x);
vec3 offset = vec3(cos(a + r * m - time) * s, 0.0, sin(a + r * m - time) * s) * vec3(0.0110) * normalize(pos).y * normalize(pos).y;
vec4 skyTextureData = textureCube(skyboxTexture, pos);
skyColor.rgb *= max(0.0, normalize(pos).y);
vec3 uvw = pos;
vec3 offset = vec3(sin(time + pos.x * s), 0.0, cos(time + pos.z * s)) * vec3(0.0110) * normalize(pos).y;
skyColor += textureCube(skyboxTexture, pos).xyz * (0.5 + strike * 0.5 * ejectionStrength + 0.5 * (1.0 - ejectionStrength));
vec4 skyTextureData = textureCube(skyboxTexture, pos, 0.0);
layout (location = 0) out vec4 FRAGCOLOR;
layout(location = 0) out vec4 _entryPointOutput;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
layout (location = 0) out vec4 FRAGCOLOR;
in vec3 pos;
color.rgb = ComputeVolumetricFog(color.rgb, pos, lightmapUv.y);
layout (location = 0) out vec4 FRAGCOLOR;
vec2 pos = uv * resolution;
color = clamp(1.0 - (pos.y + 25.0) / resolution.y, 0.0, 1.0);
out vec3 pos;
pos = instancePos;
varying vec3 pos;
pos = (gl_ModelViewMatrix * gl_Vertex).xyz;
varying vec3 pos;
pos = (gl_ModelViewMatrix * gl_Vertex).xyz;
varying vec3 pos;
pos = original.xyz;
varying vec3 pos;
pos = original.xyz;
varying vec3 pos;
pos = original.xyz;
varying vec3 pos;
vec3 uvw = pos;
float r0 = sqrt(pos.x * pos.x + pos.z * pos.z);
float a0 = atan(-pos.z, pos.x);
vec3 offset = vec3(cos(a + r * m - time) * s, 0.0, sin(a + r * m - time) * s) * vec3(0.0110) * normalize(pos).y * normalize(pos).y;
vec4 skyTextureData = textureCube(skyboxTexture, pos);
skyColor.rgb *= max(0.0, normalize(pos).y);
vec3 uvw = pos;
vec3 offset = vec3(sin(time + pos.x * s), 0.0, cos(time + pos.z * s)) * vec3(0.0110) * normalize(pos).y;
skyColor += textureCube(skyboxTexture, pos).xyz * (0.5 + strike * 0.5 * ejectionStrength + 0.5 * (1.0 - ejectionStrength));
vec4 skyTextureData = textureCube(skyboxTexture, pos, 0.0);
vec3 VP = vec3(gl_LightSource[i].position);
vec3 VP = vec3(gl_LightSource[i].position);
vec3 VP = vec3(gl_LightSource[i].position);
varying vec3 pos;
vec3 eye = normalize(-pos);
float oa = smoothstep(0.5, 3.0, length(pos));
in vec3 pos[1];
vec3 instancePos = pos[0];
out vec3 pos;
pos = localPos + chunkPos;
worldPos = pos + playerPos;
tpos = (gl_ModelViewMatrix * vec4(pos, 1.0)).xyz;
gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * vec4(pos, 1.0);
varying vec3 pos;
pos = original.xyz;
layout(location = 0) out highp vec4 _entryPointOutput;
vec2 pos = gl_FragCoord.xy;
float dis = distance(pos, center);
vec2 k = pos - innerCircleCenter;
float innerCircleDistance = distance(pos, innerCircleCenter);
vec2 uv = fract((pos) / s);
out vec3 pos;
pos = rotatedPos.xyz;
void wind(vec3 worldPos, inout vec4 pos, inout vec3 colorAdd, float power) {
pos.y -= positionIn.y * str * 0.3;
pos.xz += dtn * str * positionIn.y * 1.0;
vec4 pos = vec4(1.0);
pos.xyz = viewPos + vpos.xyz * vec3(2.0, height, 2.0);
pos.xz += downed * pos.xz * baseHeight * positionIn.y;
wind(worldPos, pos, grassColor, windPower);
pixelWorldPos = pos.xyz;
gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * pos;
vec2 pos = floor(collimator_uv*windowSize);
pos.x += time * pos.y;
float randColor = fract(sin(dot(pos.xy, vec2(12.9898,78.233))) * 43758.5453);
in vec3 pos;
float fogAmount = ComputeVolumetricFog(pos, 1.0);
vec3 fogColor = getFogColor(pos);
out vec3 pos;
pos = rotatedPos.xyz;
varying vec3 pos;
vec3 eye = normalize(-pos);
float oa = smoothstep(0.5, 3.0, length(pos));
vec3 Pos;
vec4 worldPos = vec4(Input.Pos.x, Input.Pos.y, Input.Pos.z, 1.0);
Input.Pos = Input_Pos;

=== HEALTH VARIABLES ===

=== RENDER VARIABLES ===

=== AIM VARIABLES ===
}#version 300 must be followed by es#version %d not fully supported on current GPU target profile#version 120#version %d#version 120 or later#version 120#version %d or later#version 120 or later#version 110
uniform float angle;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0.0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
original = rot(original, vec3(0.0, 1.0, 0.0), 45.0 + angle);
uniform float angle;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0.0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
original = rot(original, vec3(0.0, 1.0, 0.0), 45.0 + angle);
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
in float angle[1];
angleBiomeOut0 = vec4(angle[0], biomeColor);
angleBiomeOut1 = vec4(angle[0], biomeColor);
angleBiomeOut2 = vec4(angle[0], biomeColor);
angleBiomeOut = vec4(angle[0], biomeColor);
out float angle;
float angle = 0.0;
angle = -(atan(dt.y, dt.x) * TO_DEG + 90.0); // MAD
angle = 90.0;//angle = positionIn.w * toDeg;
angle = -(atan(dt.y, dt.x) * TO_DEG - 90.0); // MAD
angle = 90.0 + noise(positionIn.xz * 20.0) * 11810.0;//angle = positionIn.w * toDeg;
angle = 90.0 + noise(positionIn.xz * 20.0) * 11810.0;//angle = positionIn.w * toDeg;
return angle;
angle = getPatchRotation(d);
float angle = atan(-dt.x, -dt.y) + PI;
alpha -= smoothstep(0.9, 1.0, cos(angle * segments));
shadow += smoothstep(grayProgress - smoothBorder * 5.0, grayProgress, angle);
alpha -= smoothstep(grayProgress, grayProgress + smoothBorder, angle);
float red = 1.0 - smoothstep(redProgress, redProgress + smoothBorder, angle);
float power = angle / PI * 1.0;
float c = smoothstep(0.0, 0.1, 1.0 + cos(angle * segments));
in float rotation;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
vec4 rotatedPos = (vec4(modelPosition, 1.0) + rot(vertexPositionScaled, rotationVec, rotation));
uniform float angle;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0.0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
original = rot(original, vec3(0.0, 1.0, 0.0), 45.0 + angle);
in float rotation;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
vec4 rotatedPos = (vec4(modelPosition, 1.0) + rot(vertexPositionScaled, rotationVec, rotation));
float angle = atan(-dt.x, -dt.y) + PI;
alpha -= smoothstep(0.9, 1.0, cos(angle * segments));
shadow += smoothstep(grayProgress - smoothBorder * 5.0, grayProgress, angle);
alpha -= smoothstep(grayProgress, grayProgress + smoothBorder, angle);
float red = 1.0 - smoothstep(redProgress, redProgress + smoothBorder, angle);
float power = angle / PI * 1.0;
float c = smoothstep(0.0, 0.1, 1.0 + cos(angle * segments));
uniform float angle;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0.0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
original = rot(original, vec3(0.0, 1.0, 0.0), 45.0 + angle);
uniform float angle;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0.0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
original = rot(original, vec3(0.0, 1.0, 0.0), 45.0 + angle);
out float angle;
float angle = 0.0;
angle = -(atan(dt.y, dt.x) * TO_DEG + 90.0); // MAD
angle = 90.0;//angle = positionIn.w * toDeg;
angle = -(atan(dt.y, dt.x) * TO_DEG - 90.0); // MAD
angle = 90.0 + noise(positionIn.xz * 20.0) * 11810.0;//angle = positionIn.w * toDeg;
angle = 90.0 + noise(positionIn.xz * 20.0) * 11810.0;//angle = positionIn.w * toDeg;
return angle;
angle = getPatchRotation(d);
in float angle[1];
angleBiomeOut0 = vec4(angle[0], biomeColor);
angleBiomeOut1 = vec4(angle[0], biomeColor);
angleBiomeOut2 = vec4(angle[0], biomeColor);
angleBiomeOut = vec4(angle[0], biomeColor);
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
float angle = atan(-dt.x, -dt.y) + PI;
alpha -= smoothstep(0.9, 1.0, cos(angle * segments));
shadow += smoothstep(grayProgress - smoothBorder * 5.0, grayProgress, angle);
alpha -= smoothstep(grayProgress, grayProgress + smoothBorder, angle);
float red = 1.0 - smoothstep(redProgress, redProgress + smoothBorder, angle);
float power = angle / PI * 1.0;
float c = smoothstep(0.0, 0.1, 1.0 + cos(angle * segments));
out float angle;
float angle = 0.0;
angle = -(atan(dt.y, dt.x) * TO_DEG + 90.0); // MAD
angle = 90.0;//angle = positionIn.w * toDeg;
angle = -(atan(dt.y, dt.x) * TO_DEG - 90.0); // MAD
angle = 90.0 + noise(positionIn.xz * 20.0) * 11810.0;//angle = positionIn.w * toDeg;
angle = 90.0 + noise(positionIn.xz * 20.0) * 11810.0;//angle = positionIn.w * toDeg;
return angle;
angle = getPatchRotation(d);
uniform float angle;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0.0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
original = rot(original, vec3(0.0, 1.0, 0.0), 45.0 + angle);
uniform float angle;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0.0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
original = rot(original, vec3(0.0, 1.0, 0.0), 45.0 + angle);
uniform float angle;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0.0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
original = rot(original, vec3(0.0, 1.0, 0.0), 45.0 + angle);
in float angle[1];
angleBiomeOut0 = vec4(angle[0], biomeColor);
angleBiomeOut1 = vec4(angle[0], biomeColor);
angleBiomeOut2 = vec4(angle[0], biomeColor);
angleBiomeOut = vec4(angle[0], biomeColor);
uniform float angle;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0.0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
original = rot(original, vec3(0.0, 1.0, 0.0), 45.0 + angle);
in float rotation;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
vec4 rotatedPos = (vec4(modelPosition, 1.0) + rot(vertexPositionScaled, rotationVec, rotation));
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
in float rotation;
vec4 rot(vec4 vec, vec3 axis, float angle){
if (angle == 0){
angle = radians(angle);
float s = sin(angle);
float c = cos(angle);
vec4 rotatedPos = (vec4(modelPosition, 1.0) + rot(vertexPositionScaled, rotationVec, rotation));

